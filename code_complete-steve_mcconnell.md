# Глава 6. Классы

## Основы
- Одним из главных условий эффективного программирования является максимизация части программы, которую можно игнорировать при работе над конкретными фрагментами кода - *Абстрагирование*.
- Сокрытие информации - *Инкапсуляция*, позволяет упростить в дальнейшем модификацию кода, так как вся логика хранится в одном месте - методе/классе, а не разбросана по всей программе.
- Если очередь представляет ячейки электронной таблицы, обращайтесь с
ней как с набором ячеек, а не обобщенных элементов. Используйте как можно более
высокий уровень абстракции.
- Обращайтесь к Абстрактным типам данных (АТД) так, чтобы это не зависело от среды, используемой для его хранения.

## Качественные интерфейсы классов

- Интерфейс должен представлять хорошую абстракцию, скрывающую детали реализации класса;
- Интерфейс класса должен предоставлять группу методов, четко согласующихся друг с другом;
- Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса. Добавляя новый метод в интерфейс класса, всегда спрашивайте себя: «Согласуется ли этот метод с абстракцией, формируемой существующим интерфейсом?» Если нет, найдите другой способ внесения изменения, позволяющий сохранить согласованность абстракции;
- Без инкапсуляции абстракция обычно разрушается. Вы или имеете и абстракцию, и инкапсуляцию, или не имеете ни того, ни другого. Промежуточных вариантов нет;
- Если вы не можете понять, каким делать конкретный метод: открытым, закрытым или защищенным, — некоторые авторы советуют выбирать самый строгий уровень защиты, который работает;
- Предоставление доступа к данным членам нарушает инкапсуляцию и ограничивает контроль над абстракцией.

**Цените легкость чтения кода выше, чем удобство его написания**

---

- Наследование подразумевает, что один класс является более специализированным
вариантом другого класса (объяснение принципа барбары лисков);
- Если производный класс не собирается полностью придерживаться контракта,
определенного интерфейсом базового класса, наследование выполнять не стоит.
Попробуйте вместо этого применить включение или внести изменение на более
высоком уровне иерархии наследования;
- С подозрением относитесь к классам, которые переопределяют метод,
оставляя его пустым;
- Правило Деметры.

# Глава 7. Методы 

## Причины создания методов
- Самая важная причина создания метода — снижение сложности программы. Создайте метод для сокрытия информации, чтобы о ней можно было не думать. Без абстрагирующей силы методов сложные программы было бы невозможно охватить умом.
- Необходимо создавать методы для сложных булевых проверок.
- Методы позволяют выполнять оптимизацию кода в одном месте, а не в нескольких. Они облегчают профилирование кода, направленное на определение неэффективных фрагментов.
- Один из главных ментальных барьеров, препятствующих созданию эффективных методов, — нежелание создавать простой метод для простой цели.

## Именование

- Для документирования метода достаточно присвоить ему удачное имя.

- В случае методов связность характеризует соответствие выполняемых в методе операций единой цели.

- Главной задачей имени метода следует считать как можно более ясное и понятное описание сути метода, поэтому имя может иметь любую длину, удовлетворяющую этой цели.

- Дисциплинированно используйте антонимы. Применение конвенций именования, подразумевающих использование антонимов, поддерживает согласованность имен, что облегчает чтение кода. Антонимы вроде `first/last` понятны всем. Пары вроде `FileOpen()` и `_lclose()` несимметричны и вызывают замешательство.

## Параметры

- Не используйте параметры метода в качестве рабочих переменных.
- Если вы предполагаете, что передаваемые в метод данные должны иметь определенные характеристики, сразу же документируйте эти предположения. Необходимо документировать: единицы измерения. Начальное значение индекса 0 или 1.
- Если при передаче всего объекта вы создаете объект, заполняете его тремя элементами, нужными методу, а после вызова извлекаете эти элементы из объекта, значит, вам следует передать в метод только три конкретных элемента, а не весь объект.
- Используйте именованные параметры.

----

- Пусть длину метода определяют не искусственные ограничения, а такие факторы, как связность метода, глубина вложенности, число переменных, число точек принятия решений, число комментариев, необходимых для объяснения метода, и другие соображения, связанные со сложностью кода.
- Объединение вызова и проверки в одной строке увеличивает «плотность» команды, а значит, и ее сложность. `if ( report.FormatOutput( formattedReport ) = Success ) then …`
- Ты не можешь работать, если не пишешь код, чтобы прочувствовать боль и понять, что в архитектуре что-то не так.

# Глава 8. Защитное программирование

Промышленный код должен обрабатывать ошибки более изощренно, чем по
принципу «мусор на входе — мусор на выходе».

Защита программы от неправильных входных данных:
- Проверяйте все данные из внешних источников;
- Проверяйте значения всех входных параметров метода;
- Решите, как обрабатывать неправильные входные данные.

Способы обработки ошибок:
- Вернуть нейтральное значение;
- Заменить следующим корректным блоком данных;
- Вернуть тот же результат, что и в предыдущий раз;
- Подставить ближайшее допустимое значение;
- Записать предупреждающее сообщение в файл;
- Показать сообщение об ошибке, где бы она ни случилась;
- Обработать ошибку в месте возникновения наиболее подходящим способом.
	
**Корректность** предполагает, что нельзя возвращать неточный результат; лучше не вернуть ничего, чем неточное значение.

**Устойчивость** требует всегда пытаться сделать что-то, что позволит программе продолжить работу, даже если это приведет к частично неверным результатам.

## Исключения

- Основное преимущество исключений состоит в их способности сигнализировать об ошибке так, что ее нельзя проигнорировать.
- Генерируйте исключения только для действительно исключительных ситуаций. Не используйте исключения по мелочам. Если ошибка может быть обработана локально, там ее и обрабатывайте.
- Генерируйте исключения на правильном уровне абстракции, чтобы не раскрывать внутреннее устройство метода (инкапсуляция).
- Вносите в описание исключения всю информацию о его причинах.
- Избегайте пустых блоков catch.
- Рассмотрите вопрос о централизованном выводе информации об исключениях
- Стандартизуйте использование исключений в вашем проекте
- Открытые методы класса предполагают, что данные небезопасны и отвечают за их проверку и исправление. Если данные были проверены открытыми методами класса, закрытые методы могут считать, что данные безопасны.
- Исключительные случаи должны обрабатываться так, чтобы во время разработки они были очевидны, а в промышленном коде — позволяли продолжить работу.

# Глава 9. Проесс программирования с псевдокодом

После того, как в целом класс становится работоспособным (после проектирования всех методов класса) его нунжно пересмотреть и возможно разбить на несколько классов, если методы класса не согласются.

Одна из основ успеха проекта — отловить ошибку на «наименее значимой стадии», когда для ее исправления требуется минимум усилий.

Затруднения в выборе имени метода могут свидетельствовать о том, что его назначение не совсем понятно.

Обычно микрооптимизация выполняется, только когда закончена вся программа.

> Самая главная часть метода — заголовок-комментарий, описывающий действия метода, так что начните с краткой формулировки назначения метода.

Можно не писать псевдокод, но не будет лишним написать doccomment к методу, чтобы понимать суть его работы.

Если вы часто обнаруживаете, что подозреваете компилятор или
аппаратные средства в ошибке, вы в плену суеверий.

# Глава 11. Сила имен переменных

## Длинна переменной

- Слишком короткие имена переменных страдают от недостатка смысла, к тому же их сложнее найти через поиск (представьте, что вам нужно найти переменную *i*);
- Слишком длинные имена долго печатать, и к тому же они могут сделать неясной визуальную структуру программы;
- Присваивая переменной короткое имя мы указываем на её второстепенность и ограниченную область видимости;
- Спецификаторы *Total*, *Sum*, *Average*, *Max*, *Min* - лучше указывать в конце имени переменной, чтобы расположить значимую информацию вначале: *reventTotal*, *expenseAverage*.

## Именование индексов циклов

- Если переменная используется вне цикла - лучше присвоить ей более выразительное имя чем просто *i*.
- Для вложенных циклов лучше не использовать имена *i* и *j *, так как имена данные имена совершенно не информативны, к тому же их легко перепутать.

## Именование булевых переменных

- Присваивайте булевым переменным имена, подразумевающие значение *true* или *false*;
- Можно использовать префикс *is*: *isSuccess*, *isError*;
- Используйте утвердительные имена булевых переменных, *if(!notError)* читается сложнее чем *if(isError)*.

## Сокращение имен

- Не сокращайте имена без необходимости;
- Используйте общепринятые аббревиатуры (OS - Operation System);
- Не используйте сокращения вида: *before* → *b4*, *skating* → *sk8ing*;
- Сокращайте имена так, чтобы их можно было произнести;
- Старайтесь сокращать названия до трех выразительных слов;
- Стандартизируйте сокращение основных понятий вашей системы и заведите файл со списком данных оббревиатур (Reserve Bank of Russia - rbr).

## Имена которые следует избегать

- Имена переменных должны отличаться более чем на 2 символа. Примеры плохих имен переменных: *carItem* и *carItems*, *clientRecs* и *clientReps*;
- Избегате орфографических ошибок;
- Избегате использования цифр в именах переменных: file1, file2;

# Глава 12. Основные типы данных

## Числа

- Не используйте магические константы;
- При делении, всегда проверяйте может ли в знаменателе оказаться 0, чтобы избежать деления на 0; 
- Избегайте сравнения чисел с плавающей точкой. Лучше проверять допустимую разницу между числами вместо проверки их равенства;
- Часто в языке существуют специальные типы данных для работы с числами чувствительными к округлениям, например для работы с деньгами в C# есть тип `decimal`;

## Логические переменные

- Вместо длинных условий внутри `if` и `while` лучше присвоить значение переменной, которая придаст смысл данной проверке. Или с той же целью можно создать метод.
- Разбейте большое условие на несколько маленьких и присвойте результат их выполнения переменным.

## Перечисления

- Используйте перечисления вместо числовых констант;
- Используйте перечисления вместо логических переменных, так как перечисление всегда можно расширить, в то время как логические переменные всегда содержит лишь 2 значения;
- Проверяйте появление некорректных значений в операторах `if` и `case`. 

```cs
switch(color) {
    case Color.Red: ... ;
    case Color.Green: ... ;
    case Color.Blue: ... ;
    
    default: throw new NotSupportedException('...') ;
}
```

## Массивы

- При итерировании многомерных массивов необходимо убедиться, что индексы используются в правильном порядке. Для этого нужно выбирать более осмысленные названия индексов чем `i`, `j` - `Array[i][j]`.

# Глава 13. Нестандартные типы данных

Используйте структуры для упрощения списка параметров.

```js
someAction(firstName, lastName, age, address);
```

```js
someAction(human);
```

Довольно часто создание новых типов данных останавливает разработчиков использовать данный подход. Однако он упрощает модификацию кода, например, гораздо легче становится менять параметры местами или нужда в это вовсе отпадает. Однако, если в методе необходимы всего несколько параметров, то лучше передать только их. Между методами должна передаваться только та информация, которую необходимо знать.

## Глобальные данные

### Проблемы связанные с использованием глобальных данных:

- Затруднение повторного использования кода. Если класс, который вы хотите использовать повторно, читает или записывает глобальные данные, вы не сможете просто перенести его в новую программу;
- Проблемы с неопределенным порядком инициализации глобальных данных. Иногда код использующий глобальные данные может выполниться быстрее чем код, инициализирующий глобальные данные;
- Нарушение модульности;
- Возможные проблемы в многопоточном коде. Необходимо использовать блокировки, чтобы только один поток одновременно мог работать с глобально переменной.

### Причины для использования глобальных данных:

- Хранение глобальных значений: учетные данные пользователя, язык и т.д.

---

Используйте глобальные данные только как последнее средство. Сперва объявите данные локально, если данные нужны в другом методе внутри класса сделате их приватными `private`, если данные нужны в дочерних классах сделайте их защищенными `protected` и так далее. Суть в том, чтобы как можно сильнее ограничить область видимости данных.

Используйте методы доступа вместо глобальных данных. Таким образом вы ограничите область, которая будет требовать изменений в дальнейшем и с легкостью сможете изменить реализацию.

Выполняйте доступ к данным на одном и том же уровне абстракции. Если вы используете метод доступа для чтения глобальных данных, то используйте метод и доступа для записи.

Не храните промежуточных результатов в глобальных переменных. Если вам нужно вычислить новое значение глобальной переменной, присвойте ей окончательный результат в конце вычислений.
