# Глава 6. Классы

## Основы
- Одним из главных условий эффективного программирования является максимизация части программы, которую можно игнорировать при работе над конкретными фрагментами кода - *Абстрагирование*.
- Сокрытие информации - *Инкапсуляция*, позволяет упростить в дальнейшем модификацию кода, так как вся логика хранится в одном месте - методе/классе, а не разбросана по всей программе.
- Если очередь представляет ячейки электронной таблицы, обращайтесь с
ней как с набором ячеек, а не обобщенных элементов. Используйте как можно более
высокий уровень абстракции.
- Обращайтесь к Абстрактным типам данных (АТД) так, чтобы это не зависело от среды, используемой для его хранения.

## Качественные интерфейсы классов

- Интерфейс должен представлять хорошую абстракцию, скрывающую детали реализации класса;
- Интерфейс класса должен предоставлять группу методов, четко согласующихся друг с другом;
- Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса. Добавляя новый метод в интерфейс класса, всегда спрашивайте себя: «Согласуется ли этот метод с абстракцией, формируемой существующим интерфейсом?» Если нет, найдите другой способ внесения изменения, позволяющий сохранить согласованность абстракции;
- Без инкапсуляции абстракция обычно разрушается. Вы или имеете и абстракцию, и инкапсуляцию, или не имеете ни того, ни другого. Промежуточных вариантов нет;
- Если вы не можете понять, каким делать конкретный метод: открытым, закрытым или защищенным, — некоторые авторы советуют выбирать самый строгий уровень защиты, который работает;
- Предоставление доступа к данным членам нарушает инкапсуляцию и ограничивает контроль над абстракцией.

**Цените легкость чтения кода выше, чем удобство его написания**

---

- Наследование подразумевает, что один класс является более специализированным
вариантом другого класса (объяснение принципа барбары лисков);
- Если производный класс не собирается полностью придерживаться контракта,
определенного интерфейсом базового класса, наследование выполнять не стоит.
Попробуйте вместо этого применить включение или внести изменение на более
высоком уровне иерархии наследования;
- С подозрением относитесь к классам, которые переопределяют метод,
оставляя его пустым;
- Правило Деметры.

# Глава 7. Методы 

## Причины создания методов
- Самая важная причина создания метода — снижение сложности программы. Создайте метод для сокрытия информации, чтобы о ней можно было не думать. Без абстрагирующей силы методов сложные программы было бы невозможно охватить умом.
- Необходимо создавать методы для сложных булевых проверок.
- Методы позволяют выполнять оптимизацию кода в одном месте, а не в нескольких. Они облегчают профилирование кода, направленное на определение неэффективных фрагментов.
- Один из главных ментальных барьеров, препятствующих созданию эффективных методов, — нежелание создавать простой метод для простой цели.

## Именование

- Для документирования метода достаточно присвоить ему удачное имя.

- В случае методов связность характеризует соответствие выполняемых в методе операций единой цели.

- Главной задачей имени метода следует считать как можно более ясное и понятное описание сути метода, поэтому имя может иметь любую длину, удовлетворяющую этой цели.

- Дисциплинированно используйте антонимы. Применение конвенций именования, подразумевающих использование антонимов, поддерживает согласованность имен, что облегчает чтение кода. Антонимы вроде `first/last` понятны всем. Пары вроде `FileOpen()` и `_lclose()` несимметричны и вызывают замешательство.

## Параметры

- Не используйте параметры метода в качестве рабочих переменных.
- Если вы предполагаете, что передаваемые в метод данные должны иметь определенные характеристики, сразу же документируйте эти предположения. Необходимо документировать: единицы измерения. Начальное значение индекса 0 или 1.
- Если при передаче всего объекта вы создаете объект, заполняете его тремя элементами, нужными методу, а после вызова извлекаете эти элементы из объекта, значит, вам следует передать в метод только три конкретных элемента, а не весь объект.
- Используйте именованные параметры.

----

- Пусть длину метода определяют не искусственные ограничения, а такие факторы, как связность метода, глубина вложенности, число переменных, число точек принятия решений, число комментариев, необходимых для объяснения метода, и другие соображения, связанные со сложностью кода.
- Объединение вызова и проверки в одной строке увеличивает «плотность» команды, а значит, и ее сложность. `if ( report.FormatOutput( formattedReport ) = Success ) then …`
- Ты не можешь работать, если не пишешь код, чтобы прочувствовать боль и понять, что в архитектуре что-то не так.

# Глава 8. Защитное программирование

Промышленный код должен обрабатывать ошибки более изощренно, чем по
принципу «мусор на входе — мусор на выходе».

Защита программы от неправильных входных данных:
- Проверяйте все данные из внешних источников;
- Проверяйте значения всех входных параметров метода;
- Решите, как обрабатывать неправильные входные данные.

Способы обработки ошибок:
- Вернуть нейтральное значение;
- Заменить следующим корректным блоком данных;
- Вернуть тот же результат, что и в предыдущий раз;
- Подставить ближайшее допустимое значение;
- Записать предупреждающее сообщение в файл;
- Показать сообщение об ошибке, где бы она ни случилась;
- Обработать ошибку в месте возникновения наиболее подходящим способом.
	
**Корректность** предполагает, что нельзя возвращать неточный результат; лучше не вернуть ничего, чем неточное значение.

**Устойчивость** требует всегда пытаться сделать что-то, что позволит программе продолжить работу, даже если это приведет к частично неверным результатам.

## Исключения

- Основное преимущество исключений состоит в их способности сигнализировать об ошибке так, что ее нельзя проигнорировать.
- Генерируйте исключения только для действительно исключительных ситуаций. Не используйте исключения по мелочам. Если ошибка может быть обработана локально, там ее и обрабатывайте.
- Генерируйте исключения на правильном уровне абстракции, чтобы не раскрывать внутреннее устройство метода (инкапсуляция).
- Вносите в описание исключения всю информацию о его причинах.
- Избегайте пустых блоков catch.
- Рассмотрите вопрос о централизованном выводе информации об исключениях
- Стандартизуйте использование исключений в вашем проекте
- Открытые методы класса предполагают, что данные небезопасны и отвечают за их проверку и исправление. Если данные были проверены открытыми методами класса, закрытые методы могут считать, что данные безопасны.
- Исключительные случаи должны обрабатываться так, чтобы во время разработки они были очевидны, а в промышленном коде — позволяли продолжить работу.

# Глава 9. Проесс программирования с псевдокодом

После того, как в целом класс становится работоспособным (после проектирования всех методов класса) его нунжно пересмотреть и возможно разбить на несколько классов, если методы класса не согласются.

Одна из основ успеха проекта — отловить ошибку на «наименее значимой стадии», когда для ее исправления требуется минимум усилий.

Затруднения в выборе имени метода могут свидетельствовать о том, что его назначение не совсем понятно.

Обычно микрооптимизация выполняется, только когда закончена вся программа.

> Самая главная часть метода — заголовок-комментарий, описывающий действия метода, так что начните с краткой формулировки назначения метода.

Можно не писать псевдокод, но не будет лишним написать doccomment к методу, чтобы понимать суть его работы.

Если вы часто обнаруживаете, что подозреваете компилятор или
аппаратные средства в ошибке, вы в плену суеверий.

# Глава 11. Сила имен переменных

## Длинна переменной

- Слишком короткие имена переменных страдают от недостатка смысла, к тому же их сложнее найти через поиск (представьте, что вам нужно найти переменную *i*);
- Слишком длинные имена долго печатать, и к тому же они могут сделать неясной визуальную структуру программы;
- Присваивая переменной короткое имя мы указываем на её второстепенность и ограниченную область видимости;
- Спецификаторы *Total*, *Sum*, *Average*, *Max*, *Min* - лучше указывать в конце имени переменной, чтобы расположить значимую информацию вначале: *reventTotal*, *expenseAverage*.

## Именование индексов циклов

- Если переменная используется вне цикла - лучше присвоить ей более выразительное имя чем просто *i*.
- Для вложенных циклов лучше не использовать имена *i* и *j *, так как имена данные имена совершенно не информативны, к тому же их легко перепутать.

## Именование булевых переменных

- Присваивайте булевым переменным имена, подразумевающие значение *true* или *false*;
- Можно использовать префикс *is*: *isSuccess*, *isError*;
- Используйте утвердительные имена булевых переменных, *if(!notError)* читается сложнее чем *if(isError)*.

## Сокращение имен

- Не сокращайте имена без необходимости;
- Используйте общепринятые аббревиатуры (OS - Operation System);
- Не используйте сокращения вида: *before* → *b4*, *skating* → *sk8ing*;
- Сокращайте имена так, чтобы их можно было произнести;
- Старайтесь сокращать названия до трех выразительных слов;
- Стандартизируйте сокращение основных понятий вашей системы и заведите файл со списком данных оббревиатур (Reserve Bank of Russia - rbr).

## Имена которые следует избегать

- Имена переменных должны отличаться более чем на 2 символа. Примеры плохих имен переменных: *carItem* и *carItems*, *clientRecs* и *clientReps*;
- Избегате орфографических ошибок;
- Избегате использования цифр в именах переменных: file1, file2;

# Глава 12. Основные типы данных

## Числа

- Не используйте магические константы;
- При делении, всегда проверяйте может ли в знаменателе оказаться 0, чтобы избежать деления на 0; 
- Избегайте сравнения чисел с плавающей точкой. Лучше проверять допустимую разницу между числами вместо проверки их равенства;
- Часто в языке существуют специальные типы данных для работы с числами чувствительными к округлениям, например для работы с деньгами в C# есть тип `decimal`;

## Логические переменные

- Вместо длинных условий внутри `if` и `while` лучше присвоить значение переменной, которая придаст смысл данной проверке. Или с той же целью можно создать метод.
- Разбейте большое условие на несколько маленьких и присвойте результат их выполнения переменным.

## Перечисления

- Используйте перечисления вместо числовых констант;
- Используйте перечисления вместо логических переменных, так как перечисление всегда можно расширить, в то время как логические переменные всегда содержит лишь 2 значения;
- Проверяйте появление некорректных значений в операторах `if` и `case`. 

```cs
switch(color) {
    case Color.Red: ... ;
    case Color.Green: ... ;
    case Color.Blue: ... ;
    
    default: throw new NotSupportedException('...') ;
}
```

## Массивы

- При итерировании многомерных массивов необходимо убедиться, что индексы используются в правильном порядке. Для этого нужно выбирать более осмысленные названия индексов чем `i`, `j` - `Array[i][j]`.

# Глава 13. Нестандартные типы данных

Используйте структуры для упрощения списка параметров.

```js
someAction(firstName, lastName, age, address);
```

```js
someAction(human);
```

Довольно часто создание новых типов данных останавливает разработчиков использовать данный подход. Однако он упрощает модификацию кода, например, гораздо легче становится менять параметры местами или нужда в это вовсе отпадает. Однако, если в методе необходимы всего несколько параметров, то лучше передать только их. Между методами должна передаваться только та информация, которую необходимо знать.

## Глобальные данные

### Проблемы связанные с использованием глобальных данных:

- Затруднение повторного использования кода. Если класс, который вы хотите использовать повторно, читает или записывает глобальные данные, вы не сможете просто перенести его в новую программу;
- Проблемы с неопределенным порядком инициализации глобальных данных. Иногда код использующий глобальные данные может выполниться быстрее чем код, инициализирующий глобальные данные;
- Нарушение модульности;
- Возможные проблемы в многопоточном коде. Необходимо использовать блокировки, чтобы только один поток одновременно мог работать с глобально переменной.

### Причины для использования глобальных данных:

- Хранение глобальных значений: учетные данные пользователя, язык и т.д.

---

Используйте глобальные данные только как последнее средство. Сперва объявите данные локально, если данные нужны в другом методе внутри класса сделате их приватными `private`, если данные нужны в дочерних классах сделайте их защищенными `protected` и так далее. Суть в том, чтобы как можно сильнее ограничить область видимости данных.

Используйте методы доступа вместо глобальных данных. Таким образом вы ограничите область, которая будет требовать изменений в дальнейшем и с легкостью сможете изменить реализацию.

Выполняйте доступ к данным на одном и том же уровне абстракции. Если вы используете метод доступа для чтения глобальных данных, то используйте и метод доступа для записи.

Не храните промежуточных результатов в глобальных переменных. Если вам нужно вычислить новое значение глобальной переменной, присвойте ей окончательный результат в конце вычислений.

# Глава 14. Организация последовательного кода.

## 14.1 Операторы, следующие в определенном порядке

- Организуйте код так, чтобы зависимости были очевидными; В следующем примере нельзя случайно перепутать местами строки, так как результат выполнения каждой функции используется следующей.

```js
const data = readData();
const results = calculateResults(data);
console.log(results);
```

- Называйте методы так, чтобы зависимости были очевидными; В следующем примере очевидно, что сперва нужно инициализировать подключение к базе данных, прежде чем запрашивать данные. 

```js
await dataBase.initialize();
await dataBase.getUsers();
```

- Используйте параметры методов, чтобы сделать зависимости очевидными;

- Документируйте неявные зависимости с помощью комментариев. 

- Во-первых, попробуйте написать код без порядковых зависимостей, во-вторых — написать код, который делает зависимости очевидными. Если вам все еще кажется, что зависимости видны недостаточно ясно, задокументируйте их.

- Располагай взаимосвязанные действия вместе. Это улучшит читаемость. Взаимосвязанные  действия, расположенные рядом образуют обстракцию и иногда могут рассматриваться как единое действие, которое затем может быть выделено в метод.

## 14.2 Операторы, следующие в произвольном порядке

Располагайте взаимосвязанные действия вместе.

# Глава 15. Условные операторы

## 15.1 Оператор if

- Размещайте стандартный ход алгоритма после `if`, а не после `else`;

```js
if (price > 0) {
    // стандартный вариант развития событий
} else {
    // редкая ситуация
}
```

- Упрощайте сложные проверки с помощью вызовов логических функций;
- Убедитесь, что учтены все варианты. В блоке `else` необходимо добавить проверку для незапланированных ситуаций. 

## 15.2 Операторы case

- Сделайте обработку каждого варианта простой, если код обработки достаточно громоздкий, то лучше вынести обработку в отдельный метод;

- Используйте вариант по умолчанию только для обработки настоящих значений по умолчанию;

Неверное использование секции `default` для обработки значения `red`:

```cs
switch (color) {
    case 'green': /*"green" handler*/
    case 'blue': /*"blue" handler*/
    default: /*"red" handler*/
}
```

Верная обработка для значения `red`:

```cs
switch (color) {
    case 'green': /*"green" handler*/
    case 'blue': /*"blue" handler*/
    case 'red': /*"red" handler*/
    default: /*"default" value handler*/
}
```

- Используйте вариант по умолчанию для выявления ошибок.

```cs
switch (color) {
    case 'green': /*"green" handler*/
    case 'blue': /*"blue" handler*/
    case 'red': /*"red" handler*/
    default: 
        throw new NotSupportedColorException();
}
```

# 16. Циклы

- Используйте `while(true) { }` или `for(;;) {}` для реализации бесконечного цикла;
- Цикл `for` зачастую более предпочтителен, так как управляющий код находится лишь в одном месте;
- Не эмулируйте работу цикла `while` с помощью цикла `for`, используйте цикл `for` только если итерируемое значение инкрементируется или декрементируется;
- Используйте `while`, когда не известно кол-во итераций;
- Индекс цикла `for` не должен изменяться в теле цикла;
- Циклы по мере увеличения сложности: `foreach`, `for`, `while`, `do while`;
- Проверяй граничные точки цикла в уме, так можно предотвратить ошибки;
- Всегда используйте фигурные скобки `{}` для обрамления тела цикла;
- Один цикл - одно действие;
- Цикл, содержащий множество операторов `break` сигнализирует о нечетком представлении задачи цикла и вероятно требует рефакторинга;
- Используйте `continue` для проверок в начале цикла. Такое использование `continue` позволяет избегать проверок `if`, что эффективно уменьшит отступы внутри всего тела цикла. С другой стороны, если `continue` возникает в середине или конце цикла, используйте вместо него `if`;
- Использовние `break` усложняет чтение и поддержку цикла. Используйте `break`, если рассмотрели все альтернативы;
- Используйте смысловые имена переменных для вложенных циклов, вместо привычных `i`, `j`, `k`;
- Ограничивайте видимость переменных-индексов цикла самим циклом.

# 17. Нестандартные управляющие конструкции

## 17.1 Множественные возвраты из метода

- Используйте `return`, если это повышает читаемость кода;

```cs
if (age >= 18 && age <= 21) {
    return 100;
} else if (age > 21 && age <= 25) {
    return 200;
} else if (age > 25 && age < 40) {
    return 300;
}
```

- Используйте сторожевые выражения (guard expressions), для упрощения логики обработки ошибок и сокращения уровней вложенности. Лучше сперва расчистить дорогу и затем выполнить номинальный ход алгоритма.

- Минимизируйте число возвратов из каждого метода.

## 17.2 Рекурсия

- Рекурсия может быть простым и элегантным решением для небольших задач, и достаточно запутанным для больших задач.
- Основная задача при использовании рекурсии - предотвращение бесконечной рекурсии.

Советы по использованию рекурсии:
- Убедитесь, что рекурсия остановится;
- Используйте счётчик безопасности, чтобы следить за глубиной рекурсии и предотвращения её бесконечного выполнения;
- Рекурсия должна состоять из одного самовызывающего метода. Понимание нескольких функций, которые рекурсивно вызывают вдруг друга, достаточно сложно для понимания. 

# 18. Табличные методы

Основная суть табличных методов - преобразование логики в данные.

```ts
// Логика
function getDayOfWeek(index) {
    switch (index){
        case 1: return "Понеделник";
        case 2: return "Вторник";
        // ...
    }
}

// Данные
const dayOfWeekArray = [
    'Понедельник',
    'Вторник',
    //...
];
function getDayOfWeek(index) {
    return dayOfWeekArray[index];
}
```

- Для простого доступа к таблицам зачастую можно использовать данные, которые вы бы использовали в цепочках `if/else`. Если нет - то необходимо вычислять значение ключа вручную. 
- Табличные методы чем-то напоминают кэширование, сначала вы проводите некоторые вычисления и заполняете таблицу, а затем используете её - данные вместо логики.
- Данные легче изменить чем логику, так как данные могут поступать извне и могут быть изменены без изменения исходного кода.

Виды доступа к таблицам:
- Прямой - использование исходных данных в виду ключей;
- Индексированный - использование промежуточной таблицы;
- Пороговый - использование пороговых значений.

# 19. Общие вопросы управления

- Разбивайте сложные проверки на части с помощью новых логических переменных;
- Размещайте сложные выражения в логических функциях;
- В операторах `if` заменяйте негативные выражения позитивными, меняя местами блоки `if` и `else`. Или же используйте измените название переменной чтобы инвертировать смысл `!statusOk` => `errorDetected`.
- Используйте скобки для задания порядка вычисления, это надежнее и легче для чтения. List не имеет проблем с порядок вычисления, так как в нём всегда необходимо писать скобки.
- Учитывайте разницу между сравнением значений и сравнением ссылок `a == b`, `a.Equals(b)`.
- Используйте скобки `{}` вне зависимости от того сколько в нём строк 1 или 20;
- Не используйте вложенность превышающую 3 или 4 уровня;
- Уменьшайте вложенность кода с помощью вынесения части кода в отдельный метод;
- Длинные конструкции `if`/`case` можно заменить с помощью использования объектно-ориентированного подхода. В этом случае необходимо создать фабрику, которая будет создавать конкретный объект абстрактного типа. Именно данный объект и будет содержать реализацию необходимого/необходимых действий.
- Сложный код - признак плохого понимания программы.

Три компонента структурного программирования:
- Последовательность;
- Выбор;
- Итерация.
Основной тезис - любая управляющая логика может быть реализована с помощью данных трёх компонентов.

Сложность программы определяется количеством усилий необходимых для её понимания.

# 20. Качество ПО

Втурненние и внешние характеристики

Внешние характеристики — единственное что волнует пользователей. 

Улучшение одной характеристики, может негативно сказаться на другой характеристике. Пример?

Необходимо определить целевые внешние и внутренние показатели и сконцентрироваться на их достижении.

Одним из способов повышения качества являются неформальные технические обзоры - код ревью.

Цели должны быть явно заданными. Почему не все программисты пишут качественный код? Возможно у них просто нет такой цели? Проблема с его написанием связана с тем, что само понятие "качественный код" является достаточно обстрактным и сложно определимым. То, что является качественным кодом для одного, является низкокачественным для другого.

Используя только лишь тестирование, трудно добиться высоких результатов качества, необходимо применять одновременно несколько методик одновременно, например: прототипирование, парное программирование и тестирование.

Количество дефектов, найденных при чтении кода на 80% процентов больше, чем при тестировании.

Лучшим способом повышения производительности труда программистов и качества ПО является минимизация времени, затрачиваемого на исправление кода.

Устранение дефектов на самом деле — самый дорогой и длительный этап разработки ПО.

Предотвратить дефекты вместо их исправления.